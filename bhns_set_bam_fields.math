# adding requred bam fields into grid and compute them

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = READ_v(name);
C_macro2 = REALLOC_v_WRITE_v(name);
C_macro3 = DECLARE_AND_EMPTY_FIELD(name);
C_macro4 = add_alloc_get_field(name);
C_macro5 = add_alloc_field(name);

# main function:
`#include "sbh_header.h"`
``
``
`#define add_alloc_get_field(name) ADD_FIELD(name) REALLOC_v_WRITE_v(name)`
``
``
`#define add_alloc_field(name) ADD_AND_ALLOC_FIELD(name) `
``
``
`void sbh_set_bam_fields(Grid_T *const grid);`
`void sbh_set_bam_fields(Grid_T *const grid)`
`{`
`  Uint p;`
`  const Uint np = grid->np;`
``
`  OpenMP_Patch_Pragma(omp parallel for)`
`  for (p = 0; p < np; ++p)`
`  {`
`  Patch_T *patch = grid->patch[p];`
``
Declare = 
{
 # add: bam_grhd_v^i
 (obj = Field,name = bam_grhd_v, rank = U, C_macro5);

 # add: bam_grhd_rho
 (obj = Field,name = bam_grhd_rho, rank = 0, C_macro5);

 # add: bam_grhd_p
 (obj = Field,name = bam_grhd_p, rank = 0, C_macro5);

 # add: bam_grhd_epsl
 (obj = Field,name = bam_grhd_epsl, rank = 0, C_macro5);

 # add: bam_alpha
 (obj = Field,name = bam_alpha, rank = 0, C_macro4);

 # add: bam_beta^i
 (obj = Field,name = bam_beta, rank = U, C_macro4);

 # add: bam_adm_g_ij
 (obj = Field,name = bam_adm_g, rank = DD, C_macro4);

 # add: bam_adm_K_ij
 (obj = Field,name = bam_adm_Kij, rank = DD, C_macro4);

 # conformal metric 
 (obj = Field,name = gConf, rank = DD, C_macro);

 # conformal metric inverse
 #(obj = Field,name = igConf, rank = UU, C_macro);

 # K_{ij}
 (obj = Field,name = adm_Kij, rank = DD, C_macro);

 # add: bam_chi = psi^-4
 #(obj = Field,name = bam_chi, rank = 0, C_macro4);
 
 # shift
 (obj = Field,name = beta, rank = U, C_macro);

 # psi
 (obj = Field,name = psi, rank = 0, C_macro);

 # alphaPsi
 (obj = Field,name = alphaPsi, rank = 0, C_macro);

 # B1 in beta = B0+B1
 #(obj = Field,name = B1, rank = U, C_macro);
 
 # trKij
 #(obj = Field,name = K, rank = 0, C_macro);

 # enthalpy
 #(obj = Field,name = enthalpy, rank = 0, C_macro);

 # spin part of fluid
 #(obj = Field,name = W, rank = U, C_macro);

 # d(phi)/d? for irrotional part of fluid
 #(obj = Field,name = dphi, rank = D, C_macro);

 # u0
 #(obj = Field,name = u0, rank = 0, C_macro);

}

# symmetries:
Symm[adm_Kij(i,j)     = adm_Kij(j,i)];
Symm[bam_adm_Kij(i,j) = bam_adm_Kij(j,i)];
Symm[bam_adm_g(i,j)   = bam_adm_g(j,i)];
Symm[gConf(i,j)     = gConf(j,i)];
Symm[igConf(i,j)    = igConf(j,i)];

`  FOR_ALL_ijk`
`  {`
   psi4   = psi**4;

# alpha:
`   bam_alpha[ijk] = alphaPsi[ijk]/psi[ijk];`

# beta:
`   bam_beta_U0[ijk] = beta_U0[ijk];`
`   bam_beta_U1[ijk] = beta_U1[ijk];`
`   bam_beta_U2[ijk] = beta_U2[ijk];`

# g_ij:
   adm_g(-i,-j) = psi4*gConf(i,j);
   Symm[adm_g(i,j) = adm_g(j,i)];
   Cpopulate[bam_adm_g = adm_g];

# K_ij:
   Kdd(-i,-j) = adm_Kij(i,j);
   Symm[Kdd(i,j) = Kdd(j,i)];
   Cpopulate[bam_adm_Kij = Kdd];

# bam_chi (for test purposes)
#`   bam_chi[ijk] = 1/psi4;`

`  }`# FOR_ALL_ijk

`  }`# end of FOR_ALL_PATCHES

`}` # end of function
